<html>
    <head>
        <title>Boring</title>
        <style>
            body {
                font-family: sans-serif;
                color: #f0f0f0;
                background-color: black;
                margin-bottom: 0;
                margin-top: 4px;
                font-size: 17px;
            }

            u {
                text-decoration: none;
                border-bottom: 1px solid white;
            } 

            #main-view {
                border: 1px solid white;
                width: 800px;
                height: 600px;
            }

            #info {
                position: absolute;
                width: calc(100% - 830px);
                right: 5px;
                top: 5px;
            }

            #info p {
                display: block;
                border: 2px solid transparent;
                padding: 2px;
                margin: 3px;
            }

            @media(max-width: 1000px) {
                #info {
                    display: none;
                }
            }

            .highlight {
                color: yellow;
                border: 2px solid yellow !important;
            }
        </style>
    </head>
<body>
    <div id="info">
        <h1><i>Boring</i> <small>(by dramforever)</small></h1>
        <p><span>http://dram.cf/boring/</span></p>
        <p><u>左右方向键</u>控制板移动。不要让球掉到板以下。</p>
        <p>每次球掉落的时候，Combo 清零。Combo n 得 n<sup>2</sup> 分。</p>
        <p>球掉落扣 3 分。但是如果在 Combo 为 0 的时候掉落，扣 5 分。</p>
        <p id='accel'>按 <u>Shift</u> 加速。</p>
        <p id='long-bounce'>如果球在 7 秒内没有碰到大球或板，可以按 <u>Space</u> 强制使球竖直掉落。</p>
        <p id='pause'>按 <u>P</u> 或 <u>Esc</u> 暂停。按任意其它键继续。</p>
        <p>球在板上的反弹角只和碰撞的位置有关。</p>
    </div>
    <canvas id="main-view"><canvas>
    <script>
        const SCREEN = { x : 800, y : 600 };
        const BOTTOM = 570;
        const SPEED = 0.5, INITIAL_VEL = cscale (SPEED, { x : 0.6, y : - 0.8 });
        const BALL_RADIUS = 10, BLOCK_RADIUS = 50;
        const PAD = { x : 80, y : 10 };
        const GRAV_LIM = 7000;

        function square (a) { return a * a; }
        function dot (a, b) { return a.x * b.x + a.y * b.y; }
        function cross (a, b) { return a.x * b.y - b.x * a.y; }
        function cmul (a, b) {
            return {
                x: a.x * b.x - a.y * b.y,
                y: a.x * b.y + a.y * b.x};
        }
        function cscale (k, a) { return { x: k * a.x, y: k * a.y }; }
        function norm (a) { return a.x * a.x + a.y * a.y; }
        function cdiv (a, b) {
            const N = norm (b); // TODO Maybe NaN
            return {
                x: (a.x * b.x + a.y * b.y) / N,
                y: (a.y * b.x - a.x * b.y) / N};
        }
        class Game {
            constructor (ele) {
                this.canvas = ele;
                this.context = this.canvas.getContext ('2d');

                this.canvas.width = SCREEN.x * devicePixelRatio;
                this.canvas.height = SCREEN.y * devicePixelRatio;
                this.context.scale(devicePixelRatio, devicePixelRatio);

                this.ballPos = { x: SCREEN.x / 2, y : BOTTOM - BALL_RADIUS };
                this.ballVel = INITIAL_VEL;
                
                this.padPos = this.ballPos.x - PAD.x / 2;
                
                this.blockPos = { x : SCREEN.x / 2, y : 300 };
                
                this.bounceCounter = 0;

                this.combo = 0;
                this.score = 0;
                this.maxCombo = localStorage['maxCombo'] ? parseInt (localStorage['maxCombo']) : 0;

                this.prevTime = null;
                
                this.moveState = null;

                this.accel = false;

                this.keyState = {};
                
                this.running = true;

                this.hPause = document.getElementById ('pause');
                this.hAccel = document.getElementById ('accel');
                this.hLongBounce = document.getElementById ('long-bounce');

                window.onblur = (event) => {
                    this.setRunning (false);
                };

                requestAnimationFrame (this.method ('update'));
                window.onkeydown = this.method ('keyDown');
                window.onkeyup = this.method ('keyUp');
            }

            method (name) {
                return this[name].bind(this);
            }

            keyDown (event) {
                if (event.key != 'p' && event.key != 'Escape') this.setRunning (true);
                this.keyState[event.key] = true;
            }

            keyUp (event) {
                this.keyState[event.key] = false;
            }

            setRunning (st) {
                if (this.running != st) {
                    console.log (st);
                    if (st) this.hPause.classList.remove ('highlight');
                    else this.hPause.classList.add ('highlight');
                    this.running = st;
                }
            }

            clearBounceCounter () {
                this.bounceCounter = 0;
                this.hLongBounce.classList.remove ('highlight');
            }

            update (time) {
                if (this.prevTime == null)
                    this.prevTime = time;
                else {
                    const dt = time - this.prevTime;
                    if (this.running && dt < 80) {
                        // If the animation hasn't stopped, then animations will make sense
                        // Otherwise we just skip this frame and try again
                        this.handleInput (dt);
                        this.updatePhysics (dt);
                    }
                    this.draw ();
                    this.prevTime = time;
                }
                requestAnimationFrame (this.method ('update'));
            }

            handleInput (dt) {
                if (this.keyState['p'] || this.keyState['Escape'])
                    this.setRunning (false);

                if (this.accel != this.keyState['Shift']) {
                    if (this.keyState['Shift']) this.hAccel.classList.add ('highlight');
                    else this.hAccel.classList.remove ('highlight');
                    this.accel = this.keyState['Shift'];
                }

                if (this.keyState['ArrowLeft'] && !this.keyState['ArrowRight'])
                    this.moveState = 'left';
                else if (this.keyState['ArrowRight'] && !this.keyState['ArrowLeft'])
                    this.moveState = 'right';
                else
                    this.moveState = null;

                if (this.keyState[' '] && this.bounceCounter > GRAV_LIM) {
                    this.ballVel = { x: 0, y: SPEED };
                    this.clearBounceCounter ();
                }

                const moveAmount = dt * SPEED * (this.accel ? 5.0 : 0.8);
                if (this.moveState == 'left') {
                    this.padPos -= moveAmount;
                    if (this.padPos < - PAD.x / 2) this.padPos = - PAD.x / 2;
                } else if (this.moveState == 'right') {
                    this.padPos += moveAmount;
                    if (this.padPos > SCREEN.x - PAD.x / 2) this.padPos = SCREEN.x - PAD.x / 2;
                }
            }

            reflectVel (d) {
                const v = this.ballVel;
                return cscale (- norm (v) / norm (d), cmul (d, cdiv (d, v)));
            }
            
            updatePhysics (dt) {
                let bp = this.ballPos;
                let bv = this.ballVel;
                const oldBallPos = { x: bp.x, y: bp.y };

                for (let ax of ['x', 'y'])
                    bp[ax] += dt * bv[ax];

                if ((bp.x < BALL_RADIUS && bv.x < 0)
                    || (bp.x >= SCREEN.x && bv.x > 0))
                    bv.x *= -1;
                
                if (bp.y < BALL_RADIUS && bv.y < 0)
                    bv.y *= -1;
                
                if (oldBallPos.y < BOTTOM - BALL_RADIUS && bp.y >= BOTTOM - BALL_RADIUS
                    && bp.x >= this.padPos - BALL_RADIUS && bp.x < this.padPos + PAD.x + BALL_RADIUS) {
                    const vx = (bp.x - this.padPos - PAD.x / 2) / (BALL_RADIUS + 0.5 * PAD.x);
                    bv = { x: vx * SPEED, y: (- Math.sqrt (1 + 1e-7 - vx * vx)) * SPEED };
                    this.clearBounceCounter ();
                }

                if (bp.y > SCREEN.y + BALL_RADIUS) {
                    bv = INITIAL_VEL;
                    bp = { x: this.padPos + PAD.x / 2, y : BOTTOM - BALL_RADIUS - 1 };
                    this.clearBounceCounter ();
                    if (this.combo) this.score -= 3;
                    else this.score -= 5;
                    this.combo = 0;
                }

                const d = { x: this.blockPos.x - bp.x, y: this.blockPos.y - bp.y };
                if (norm (d) < square (BALL_RADIUS + BLOCK_RADIUS) && dot (d, bv) > 0) {
                    bv = this.reflectVel (d);
                    let newPos;
                    do newPos = {
                        x: Math.random () * (SCREEN.x - 2 * BLOCK_RADIUS) + BLOCK_RADIUS,
                        y: Math.random () * (BOTTOM * 0.6 - 3 * BLOCK_RADIUS) + BLOCK_RADIUS};
                    while (square (newPos.x - this.blockPos.x) + square (newPos.y - this.blockPos.y) <
                        square (BLOCK_RADIUS) * 8)
                    this.blockPos = newPos;
                    this.combo ++;
                    if (this.combo > this.maxCombo)
                        localStorage['maxCombo'] = this.maxCombo = this.combo;
                    this.score += this.combo * 2 - 1;
                    this.clearBounceCounter ();
                }

                if (this.bounceCounter < GRAV_LIM && this.bounceCounter + dt > GRAV_LIM) {
                    this.hLongBounce.classList.add ('highlight');
                }
                this.bounceCounter += dt;
                this.ballPos = bp;
                this.ballVel = bv;
            }

            draw () {
                // TODO abstract over drawing
                this.context.clearRect (0, 0, SCREEN.x, SCREEN.y);

                this.context.fillStyle = 'black';
                this.context.fillRect (0, 0, SCREEN.x, SCREEN.y);

                this.context.fillStyle = (this.bounceCounter > GRAV_LIM) ? '#ff2222' : '#22ff22';
                this.context.beginPath ();
                this.context.arc (this.ballPos.x, this.ballPos.y, BALL_RADIUS, 0, 2 * Math.PI, false);
                this.context.fill ();

                this.context.fillStyle = '#2222ff';
                this.context.beginPath ();
                this.context.arc (this.blockPos.x, this.blockPos.y, BLOCK_RADIUS, 0, 2 * Math.PI, false);
                this.context.fill ();

                this.context.fillStyle = this.accel ? 'yellow' : '#66ccff';
                this.context.fillRect (this.padPos, BOTTOM, PAD.x, PAD.y);

                this.context.fillStyle = '#ff77cc';
                this.context.font = '25px sans-serif';
                this.context.fillText (`Combo: ${this.combo} (Best: ${this.maxCombo})`, 20, 35);
                this.context.font = '17px sans-serif';
                this.context.fillText (`Score: ${this.score}`, 20, 60);

                if (! this.running) {
                    this.context.fillStyle = '#ff0000'
                    this.context.font = '70px sans-serif';
                    const width = this.context.measureText('Pause').width;
                    this.context.fillText ('Pause', (SCREEN.x - width) / 2, 200);
                }
            }
        }

        const game = new Game (document.getElementById ('main-view'));
    </script>
</body>
</html>