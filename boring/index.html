<html>
    <head>
        <title>Boring</title>
        <style>
            body {
                font-family: sans-serif;
                color: #f0f0f0;
                background-color: black;
                margin-bottom: 0;
                margin-top: 4px;
                font-size: 17px;
            }

            u {
                text-decoration: none;
                border-bottom: 1px solid;
                border-color: inherit;
            } 

            #main-view {
                border: 1px solid white;
                width: 800px;
                height: 600px;
            }

            #info {
                position: absolute;
                width: calc(100% - 830px);
                right: 5px;
                top: 5px;
            }

            #info p {
                display: block;
                border: 2px solid transparent;
                padding: 4px 2px;
                margin: 3px;
            }

            @media(max-width: 1000px) {
                #info {
                    display: none;
                }
            }

            #info:not(.running) #pause {
                color: yellow;
                border-color: yellow;
            }


            #info:not(.flying) #launch {
                color: yellow;
                border-color: yellow;
            }

            #info.long-bounce #long-bounce {
                color: yellow;
                border-color: yellow;
            }

            #info.flying #move {
                color: yellow;
                border-color: yellow;
            }

            #info.miss #miss {
                color: yellow;
                border-color: yellow;
            }
        </style>
    </head>
<body>
    <div id="info">
        <h1><i>Boring</i> <small>(by dramforever)</small></h1>
        <p><span>http://dram.cf/boring/</span></p>
        <p id="launch">按 <u>Space</u> 发射。</p>
        <p id="move"><u>左右方向键</u>控制板移动。不要让球掉到板以下。</p>
        <p id="miss">
            Combo n 得 n<sup>2</sup> 分。每次球掉落扣 3 分，Combo 清零。但是如果在 Combo 为 0 的时候掉落，扣 5 分。
        </p>
        <p id='accel'>按 <u>Shift</u> 加速。</p>
        <p id='long-bounce'>如果球在 5 秒内没有碰到大球或板，可以按 <u>Space</u> 强制使球竖直掉落。</p>
        <p id='pause'>按 <u>P</u> 或 <u>Esc</u> 暂停。按任意其它键继续。</p>
        <p>球在板上的反弹角只和碰撞的位置有关。</p>
    </div>
    <canvas id="main-view"><canvas>
    <script>
        const kEsc = 27, kP = 80, kLeft = 37, kRight = 39, kShift = 16, kSpace = 32;
        const SCREEN = { x : 800, y : 600 };
        const BOTTOM = 570;
        const SPEED = 0.5, INITIAL_VEL = () => cscale (SPEED, { x : 0.6, y : - 0.8 });
        const BALL_RADIUS = 10, BLOCK_RADIUS = 50;
        const PAD = { x : 80, y : 10 };
        const GRAV_LIM = 5000;

        function square (a) { return a * a; }
        function dot (a, b) { return a.x * b.x + a.y * b.y; }
        function cross (a, b) { return a.x * b.y - b.x * a.y; }
        function cmul (a, b) {
            return {
                x: a.x * b.x - a.y * b.y,
                y: a.x * b.y + a.y * b.x};
        }
        function cscale (k, a) { return { x: k * a.x, y: k * a.y }; }
        function norm (a) { return a.x * a.x + a.y * a.y; }
        function cdiv (a, b) {
            const N = norm (b); // TODO Maybe NaN
            return {
                x: (a.x * b.x + a.y * b.y) / N,
                y: (a.y * b.x - a.x * b.y) / N};
        }
        class Game {
            constructor (ele) {
                this.hInfo = document.getElementById ('info');

                this.canvas = ele;
                this.context = this.canvas.getContext ('2d');

                this.canvas.width = SCREEN.x * devicePixelRatio;
                this.canvas.height = SCREEN.y * devicePixelRatio;
                this.context.scale(devicePixelRatio, devicePixelRatio);

                this.ballPos = { x: SCREEN.x / 2, y : BOTTOM - BALL_RADIUS };
                this.ballVel = INITIAL_VEL ();
                
                this.padPos = this.ballPos.x - PAD.x / 2;
                
                this.blockPos = { x : SCREEN.x / 2, y : 300 };
                
                this.bounceCounter = 0;

                this.combo = 0;
                this.score = 0;
                this.maxCombo = localStorage['maxCombo'] ? parseInt (localStorage['maxCombo']) : 0;

                this.prevTime = null;
                
                this.moveState = null;

                this.accel = false;

                this.keyState = {};
                
                this.flying = false;
                this.hInfo.classList.remove ('flying');

                this.running = true;
                this.hInfo.classList.add ('running');

                window.onblur = (event) => {
                    this.setRunning (false);
                };

                requestAnimationFrame (this.method ('update'));
                window.onkeydown = this.method ('keyDown');
                window.onkeyup = this.method ('keyUp');
            }

            method (name) {
                return this[name].bind(this);
            }

            keyDown (event) {
                if (event.keyCode != kP && event.key != kEsc) this.setRunning (true);
                this.keyState[event.keyCode] = true;
            }

            keyUp (event) {
                this.keyState[event.keyCode] = false;
            }

            setRunning (st) {
                if (this.running != st) {
                    console.log (st);
                    if (st) this.hInfo.classList.add ('running');
                    else this.hInfo.classList.remove ('running');
                    this.running = st;
                }
            }

            clearBounceCounter () {
                this.bounceCounter = 0;
                this.hInfo.classList.remove ('long-bounce');
            }

            update (time) {
                if (this.prevTime == null)
                    this.prevTime = time;
                else {
                    const dt = time - this.prevTime;
                    if (this.running && dt < 100) {
                        // If the animation hasn't stopped, then animations will make sense
                        // Otherwise we just skip this frame and try again
                        this.handleInput (dt);
                        this.updatePhysics (dt);
                    }
                    this.draw ();
                    this.prevTime = time;
                }
                requestAnimationFrame (this.method ('update'));
            }

            handleInput (dt) {
                if (this.keyState[kP] || this.keyState[kEsc])
                    this.setRunning (false);

                if (this.accel != this.keyState[kShift]) {
                    if (this.keyState[kShift]) this.hInfo.classList.add ('accel');
                    else this.hInfo.classList.remove ('accel');
                    this.accel = this.keyState[kShift];
                }

                if (this.keyState[kLeft] && !this.keyState[kRight])
                    this.moveState = 'left';
                else if (this.keyState[kRight] && !this.keyState[kLeft])
                    this.moveState = 'right';
                else
                    this.moveState = null;

                if (this.keyState[kSpace]) {
                    if (this.bounceCounter > GRAV_LIM) {
                        this.ballVel = { x: 0, y: SPEED };
                        this.clearBounceCounter ();
                    }
                    if (! this.flying) {
                        this.ballVel = INITIAL_VEL ();
                        this.flying = true;
                        this.hInfo.classList.add ('flying');
                    }
                }

                const moveAmount = dt * SPEED * (this.accel ? 5.0 : 0.8);
                if (this.moveState == 'left') {
                    this.padPos -= moveAmount;
                    if (this.padPos < - PAD.x / 2) this.padPos = - PAD.x / 2;
                } else if (this.moveState == 'right') {
                    this.padPos += moveAmount;
                    if (this.padPos > SCREEN.x - PAD.x / 2) this.padPos = SCREEN.x - PAD.x / 2;
                }
            }

            reflectVel (d) {
                const v = this.ballVel;
                return cscale (- norm (v) / norm (d), cmul (d, cdiv (d, v)));
            }
            
            updatePhysics (dt) {
                if (this.flying) {
                    let bp = this.ballPos;
                    let bv = this.ballVel;
                    const oldBallPos = { x: bp.x, y: bp.y };

                    for (let ax of ['x', 'y'])
                        bp[ax] += dt * bv[ax];

                    if ((bp.x < BALL_RADIUS && bv.x < 0)
                        || (bp.x >= SCREEN.x && bv.x > 0))
                        bv.x *= -1;
                    
                    if (bp.y < BALL_RADIUS && bv.y < 0)
                        bv.y *= -1;
                    
                    if (oldBallPos.y < BOTTOM - BALL_RADIUS && bp.y >= BOTTOM - BALL_RADIUS
                        && bp.x >= this.padPos - BALL_RADIUS && bp.x < this.padPos + PAD.x + BALL_RADIUS) {
                        const vx = (bp.x - this.padPos - PAD.x / 2) / (BALL_RADIUS + 0.5 * PAD.x);
                        bv = { x: vx * SPEED, y: (- Math.sqrt (1 + 1e-7 - vx * vx)) * SPEED };
                        console.log ('bounce');
                        this.clearBounceCounter ();
                    }

                    if (bp.y > SCREEN.y + BALL_RADIUS) {
                        bv = INITIAL_VEL ();
                        bp = { x: this.padPos + PAD.x / 2, y : BOTTOM - BALL_RADIUS - 1 };
                        this.clearBounceCounter ();
                        if (this.combo) this.score -= 3;
                        else this.score -= 5;
                        this.combo = 0;
                        this.flying = false;
                        this.hInfo.classList.remove ('flying');
                        if (! this.hInfo.classList.contains ('miss')) {
                            this.hInfo.classList.add ('miss');
                            setTimeout (() => { this.hInfo.classList.remove ('miss'); }, 800);
                        }
                    }

                    const d = { x: this.blockPos.x - bp.x, y: this.blockPos.y - bp.y - 1e-3 };

                    if (norm (d) < square (BALL_RADIUS + BLOCK_RADIUS) && dot (d, bv) > 0) {
                        bv = this.reflectVel (d);
                        let newPos;
                        do newPos = {
                            x: Math.random () * (SCREEN.x - 2 * BLOCK_RADIUS) + BLOCK_RADIUS,
                            y: Math.random () * (BOTTOM * 0.6 - 3 * BLOCK_RADIUS) + BLOCK_RADIUS};
                        while (square (newPos.x - this.blockPos.x) + square (newPos.y - this.blockPos.y) <
                            square (BLOCK_RADIUS) * 8)
                        this.blockPos = newPos;
                        this.combo ++;
                        if (this.combo > this.maxCombo)
                            localStorage['maxCombo'] = this.maxCombo = this.combo;
                        this.score += this.combo * 2 - 1;
                        this.clearBounceCounter ();
                    }

                    if (this.bounceCounter < GRAV_LIM && this.bounceCounter + dt > GRAV_LIM) {
                        this.hInfo.classList.add ('long-bounce');
                    }

                    this.bounceCounter += dt;
                    this.ballPos = bp;
                    this.ballVel = bv;
                } else {
                    this.ballPos = { x: this.padPos + PAD.x / 2, y: BOTTOM - BALL_RADIUS };
                }
            }

            draw () {
                // TODO abstract over drawing
                this.context.clearRect (0, 0, SCREEN.x, SCREEN.y);

                this.context.fillStyle = 'black';
                this.context.fillRect (0, 0, SCREEN.x, SCREEN.y);

                this.context.fillStyle = (this.bounceCounter > GRAV_LIM) ? '#ff2222' : '#22ff22';
                this.context.beginPath ();
                this.context.arc (this.ballPos.x, this.ballPos.y, BALL_RADIUS, 0, 2 * Math.PI, false);
                this.context.fill ();

                this.context.fillStyle = '#2222ff';
                this.context.beginPath ();
                this.context.arc (this.blockPos.x, this.blockPos.y, BLOCK_RADIUS, 0, 2 * Math.PI, false);
                this.context.fill ();

                this.context.fillStyle = this.accel ? 'yellow' : '#66ccff';
                this.context.fillRect (this.padPos, BOTTOM, PAD.x, PAD.y);

                this.context.fillStyle = '#ff77cc';
                this.context.font = '25px sans-serif';
                this.context.fillText (`Combo: ${this.combo} (Best: ${this.maxCombo})`, 20, 35);
                this.context.font = '17px sans-serif';
                this.context.fillText (`Score: ${this.score}`, 20, 60);

                if (! this.running) {
                    this.context.fillStyle = '#ff0000'
                    this.context.font = '70px sans-serif';
                    const width = this.context.measureText('Pause').width;
                    this.context.fillText ('Pause', (SCREEN.x - width) / 2, 200);
                }
            }
        }

        const game = new Game (document.getElementById ('main-view'));
    </script>
</body>
</html>